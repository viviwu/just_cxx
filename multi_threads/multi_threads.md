在 C/C++ 中，提供了多种加锁的方法用于保护共享资源，常用的有以下几种：

1. 互斥锁（mutex）：通过在共享资源访问前加锁，让只有获得锁的线程才能访问共享资源。互斥锁是最常用的加锁方式之一，可以通过 `std::mutex` 类来实现。

2. 递归锁（recursive_mutex）：允许同一线程多次获得同一个锁，这在某些情况下可以避免死锁。递归锁可以通过 `std::recursive_mutex` 类来实现。

3. 条件变量（condition_variable）：用于等待某个条件变为真，当条件不满足时，线程可以等待在条件变量上，而不是忙等待，从而降低资源占用。条件变量可以通过 `std::condition_variable` 类来实现。

4. 读写锁（read-write lock）：将锁分为读锁和写锁，当多个线程只读共享资源时，可以使用读锁，而当有线程写共享资源时，需要使用写锁。读写锁可以通过 `std::shared_mutex` 类来实现。

5. 原子变量（atomic）：用于保持原子性操作，即对共享变量的读写操作是原子的，不会被其他线程中断。原子变量可以通过 `std::atomic` 类来实现。

以上是常见的几种加锁方式，每种方式都有不同的适用场景和优缺点。在实际编程中，我们需要根据具体情况选择合适的加锁方式，以确保线程之间的正确交互和高效协作。